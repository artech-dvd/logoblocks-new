;;;; OBJECTS for the VPL;;;; Andrew Begel 4/6/95;;;; fixed up OOP stuff 8/9/95;--------------- OBJECT METHODS ---------------------------------------(defmethod move-object ((obj object) new-location)  (let ((diff-loc (subtract-points new-location (topleft (boundrect obj)))))    (offset-rect (boundrect obj) diff-loc)    (offset-region (boundrgn obj) diff-loc)))(defmethod pre-move ((view main) (obj object))  ())(defmethod after-move ((view main) (obj object))  ())(defmethod delete-object ((obj object))  (dispose-region (boundrgn obj))  (dispose-record (boundrect obj)))(defmethod change-definition ((view interface-view) (obj object) where)  (declare (ignore where))  (setf (definition obj) (append (cdr (definition obj))                                 (list (first (definition obj)))))  (setf (currentdef obj) (car (definition obj)))  (draw view (list obj))  (view-draw-contents view))(defmethod snap-objs ((obj object) list-of-objs)  (declare (ignore obj list-of-objs))) (defmethod snap ((obj object) (backobj object) angle)  (declare (ignore angle obj backobj)));--------------- ACTION OBJECT -----------------------------------------(defvar action-box-region)(defun init-action ()  (unless standalone?    (my-open-resource-file "home:visual-logo-resources"))    (let ((action-pict (my-get-resource "PICT" "action")))      (unless standalone?         (my-close-resource-file))      (setf action-box-region (get-region-from-pict action-pict))))  (defun make-action (name color-list definition location)  (let* ((boundrgn (copy-region action-box-region))         (boundrect (bound-region-rect boundrgn)))    (move-rect boundrect location)    (move-region boundrgn location)    (let ((obj (make-instance 'action                 :name name                 :color-list color-list                 :definition definition                 :currentdef (car definition)                 :boundrect boundrect                 :boundrgn boundrgn                 :left-func-target #@(-32 -26))))      obj))) (defmethod copy-obj ((obj action))  (make-action (name obj) (color-list obj) (definition obj)               (topleft (boundrect obj))))(defmethod draw-object ((obj action) grafport)  (draw-action (boundrect obj) (boundrgn obj)                (color-list obj) (symbol-name (currentdef obj))               (selected? obj)))  ;;; then draw the text(defun draw-action (boundrect boundrgn color-list definition selected?)  (with-fore-color (if selected? *gray-color*                       (car color-list))    (#_paintrgn boundrgn))  (let ((xpos (+ 1 (left boundrect) (- (truncate (/ (rect-width boundrect) 2))                                        (truncate (/ (string-width definition) 2)))))        (ypos (+ (top boundrect) 16)))    (#_moveto xpos ypos)    (with-fore-color (cadr color-list)      (with-pstrs ((string definition))        (#_Drawstring string)))))(defmethod erase-object ((obj action) grafport)  (declare (ignore grafport))  (erase-action (boundrgn obj)))(defun erase-action (boundrgn)  (#_erasergn boundrgn))(defmethod save-object ((obj action))  (append (list 'action                 (name obj)                (car (color-list obj))                (cadr (color-list obj))                (topleft (boundrect obj)))          (definition obj)));;; getting info to recreate an action-box;;; same order as the saved list, but all in string format(defun recreate-action (list-of-traits)  (let* ((name (pop list-of-traits))         (color-list (list (parse-integer (pop list-of-traits))                           (parse-integer (pop list-of-traits))))         (topleft (parse-integer (pop list-of-traits)))         (definition (loop while (not (null list-of-traits))                           collect (read-from-string (pop list-of-traits)))))    (make-action name color-list definition topleft)))(defmethod snap-objs ((obj action) list-of-objs)  (rlet ((rect :rect :topleft #@(0 0) :botright #@(0 0)))    (let ((temp-rect (copy-rect (boundrect obj))))      (inset-rect temp-rect -3 -3)      (loop for backobj in list-of-objs            unless (equal backobj obj)            do (intersect-rect temp-rect (boundrect backobj) rect)            and unless (empty-rect-p rect)            do (let ((angle (point-to-angle (boundrect obj)                                                 (center-rect (boundrect backobj)))))                 (snap obj backobj angle)))      (dispose-record temp-rect))))  (defmethod snap ((obj action) (backobj action) angle)  (snap-box obj backobj angle))(defmethod snap ((obj action) (backobj digital) angle)  (snap-box obj backobj angle))(defmethod snap ((obj action) (backobj analog) angle)  (snap-box-not-left obj backobj angle))(defmethod snap ((obj action) (backobj action-input) angle)  (snap-box-not-left obj backobj angle))(defmethod snap ((obj action) (backobj proc) angle)  (snap-box-proc-all obj backobj angle))(defmethod snap ((obj action) (backobj repeat) angle)  (if (top? angle)    (snap-to obj backobj (bot-target backobj))    (if (Bottom? angle)      (snap-to obj backobj (top-target backobj))      (if (topleft? angle)        (snap-to obj backobj (func-target backobj))        (when (right? angle)          (snap-to obj backobj (left-target backobj)))))))(defmethod snap ((obj action) (backobj number-var) angle)  (when (left? angle)    (snap-to obj backobj (right-target backobj))));--------------- ACTION w/INPUT -----------------------------------------;action box's are 30 pixels high(defvar action-region-left)(defvar action-region-right);; load up the picts from the resource file;; then get their regions and store them. That's all we want.(defun init-action-input ()  (unless standalone?     (my-open-resource-file "home:visual-logo-resources"))  (let ((action-pict-left (my-get-resource "PICT" "action-input-left"))        (action-pict-right (my-get-resource "PICT" "action-input-right")))    (unless standalone?       (my-close-resource-file))    (setf action-region-left (get-region-from-pict action-pict-left))    (setf action-region-right (get-region-from-pict action-pict-right))))  ;;num-target is a target point for a number-var object to be in the block(defun make-action-input (name color-list definition location orient)  (let* ((boundrgn (if (eq orient 'left)                     (copy-region action-region-left)                     (copy-region action-region-right)))         (boundrect (bound-region-rect boundrgn)))    (move-rect boundrect location)    (move-region boundrgn location)    (let ((obj (make-instance 'action-input                 :name name                 :color-list color-list                 :definition definition                 :currentdef (car definition)                 :boundrect boundrect                 :boundrgn boundrgn                 :orient orient                 :num-target #@(33 3)                 :right-num-target #@(-33 -26)                 :left-func-target #@(-32 -26))))      obj))) (defmethod copy-obj ((obj action-input))  (make-action-input (name obj) (color-list obj) (definition obj)                     (topleft (boundrect obj)) (orient obj)))(defmethod draw-object ((obj action-input) grafport)  (draw-action-input (boundrect obj)                      (boundrgn obj) (color-list obj)                     (symbol-name (currentdef obj))                     (selected? obj)));;; then draw the text(defun draw-action-input (boundrect boundrgn color-list definition selected?)  (with-fore-color (if selected? *gray-color*                        (car color-list))    (#_paintrgn boundrgn))  (let ((xpos (+ -6 (left boundrect) (- (truncate (/ (rect-width boundrect) 2))                                        (truncate (/ (string-width definition) 2)))))        (ypos (+ (top boundrect) 16)))    (#_moveto xpos ypos)    (with-fore-color (cadr color-list)      (with-pstrs ((string definition))        (#_Drawstring string)))))(defmethod erase-object ((obj action-input) grafport)  (erase-action-input (boundrgn obj)))(defun erase-action-input (boundrgn)  (#_erasergn boundrgn))(defmethod save-object ((obj action-input))  (append (list 'action-input                 (name obj)                (car (color-list obj))                (cadr (color-list obj))                (topleft (boundrect obj))                (orient obj))          (definition obj)));;; getting info to recreate an action-input-box;;; same order as the saved list, but all in string format(defun recreate-action-input (list-of-traits)  (let* ((name (pop list-of-traits))         (color-list (list (parse-integer (pop list-of-traits))                           (parse-integer (pop list-of-traits))))                  (topleft (parse-integer (pop list-of-traits)))         (orient (read-from-string (pop list-of-traits)))         (definition (loop while (not (null list-of-traits))                           collect (read-from-string (pop list-of-traits)))))    (make-action-input name color-list definition topleft orient)))(defmethod snap-objs ((obj action-input) list-of-objs)  (rlet ((rect :rect :topleft #@(0 0) :botright #@(0 0)))    (let ((temp-rect (copy-rect (boundrect obj))))      (inset-rect temp-rect -3 -3)      (loop for backobj in list-of-objs            unless (equal backobj obj)            do (intersect-rect temp-rect (boundrect backobj) rect)            and unless (empty-rect-p rect)            do (let ((angle (point-to-angle (boundrect obj)                                               (center-rect (boundrect backobj)))))                 (snap obj backobj angle)))      (dispose-record temp-rect))))(defmethod snap ((obj action-input) (backobj action) angle)  (snap-box-not-right obj backobj angle))(defmethod snap ((obj action-input) (backobj digital) angle)  (snap-box-not-right obj backobj angle))(defmethod snap ((obj action-input) (backobj analog) angle)  (snap-box-not-right-or-left obj backobj angle))(defmethod snap ((obj action-input) (backobj action-input) angle)  (if (top? angle)    (snap-to obj backobj (bot-target backobj))    (if (Bottom? angle)      (snap-to obj backobj (top-target backobj)))))(defmethod snap ((obj action-input) (backobj proc) angle)  (snap-box-proc-not-right obj backobj angle))(defmethod snap ((obj action-input) (backobj repeat) angle)  (if (top? angle)    (snap-to obj backobj (bot-target backobj))    (if (bottom? angle)      (snap-to obj backobj (top-target backobj))      (if (topleft? angle)        (snap-to obj backobj (func-target backobj))        (if (left? angle)          (snap-to obj backobj (right-target backobj)))))))(defmethod snap ((obj action-input) (backobj number-var) angle)  (if (right? angle)    (snap-to obj backobj (right-num-target backobj))    (if (left? angle)      (snap-to obj backobj (right-target backobj)))));------------------- ACTION w/ 2 INPUTS ---------------------------; REPEAT(defvar action2input-region)(defun init-action-2input ()  (unless standalone?    (my-open-resource-file "home:visual-logo-resources"))  (let ((action2input-pict (my-get-resource "PICT" "repeat")))    (unless standalone?      (my-close-resource-file))    (setf action2input-region (get-region-from-pict action2input-pict))))  (defun make-repeat (name color-list definition location)  (let* ((boundrgn (copy-region action2input-region))         (boundrect (bound-region-rect boundrgn)))    (move-rect boundrect location)    (move-region boundrgn location)    (let ((obj (make-instance 'repeat                 :name name                 :color-list color-list                 :definition definition                 :currentdef (car definition)                 :boundrect boundrect                 :boundrgn boundrgn                 :num-target #@(33 3)                 :func-target #@(32 26)                 :bot-target #@(0 55)                 :bot-proc-target #@(9 55)                 :left-proc-target #@(-31 14)                 :left-target #@(-49 15))))      obj)))(defmethod copy-obj ((obj repeat))  (make-repeat (name obj) (color-list obj) (definition obj)               (topleft (boundrect obj))))(defmethod draw-object ((obj action-2input) grafport)  (draw-action-2input (boundrect obj) (boundrgn obj)                       (color-list obj) (symbol-name (currentdef obj))                      (selected? obj)));;; then draw the text(defun draw-action-2input (boundrect boundrgn color-list definition selected?)  (with-fore-color (if selected? *gray-color*                       (car color-list))    (#_paintrgn boundrgn))  (let ((xpos (+ -3 (left boundrect) (- (truncate (/ (rect-width boundrect) 2))                                       (truncate (/ (string-width definition) 2)))))        (ypos (+ (top boundrect) 26)))    (#_moveto xpos ypos)    (with-fore-color (cadr color-list)      (with-pstrs ((string definition))        (#_Drawstring string)))))(defmethod erase-object ((obj action-2input) grafport)  (erase-action-2input (boundrgn obj)))(defun erase-action-2input (boundrgn)  (#_erasergn boundrgn))(defmethod save-object ((obj repeat))  (append (list 'repeat                 (name obj)                (Car (color-list obj))                (cadr (Color-list obj))                (topleft (boundrect obj)))          (definition obj)));;; getting info to recreate a repeat block;;; same order as the saved list, but all in string format(defun recreate-repeat (list-of-traits)  (let* ((name (pop list-of-traits))         (color-list (list (parse-integer (pop list-of-traits))                           (parse-integer (pop list-of-traits))))         (topleft (parse-integer (pop list-of-traits)))         (definition (loop while (not (null list-of-traits))                           collect (read-from-string (pop list-of-traits)))))    (make-repeat name color-list definition topleft)))(defmethod snap-objs ((obj repeat) list-of-objs)  (rlet ((rect :rect :topleft #@(0 0) :botright #@(0 0)))    (let ((temp-rect (copy-rect (boundrect obj))))      (inset-rect temp-rect -3 -3)      (loop for backobj in list-of-objs            unless (equal backobj obj)            do (intersect-rect temp-rect (boundrect backobj) rect)            and unless (empty-rect-p rect)            do (let ((angle (point-to-angle (boundrect obj)                                               (center-rect (boundrect backobj)))))                 (snap obj backobj angle)))      (dispose-record temp-rect))))(defmethod snap ((obj repeat) (backobj action) angle)  (if (top? angle)    (snap-to obj backobj (bot-target backobj))    (if (left? angle)      (snap-to obj backobj (right-repeat-target backobj))      (if (botright? angle)        (snap-to obj backobj (left-func-target backobj))        (if (bottom? angle)          (snap-to obj backobj (top-repeat-target backobj)))))))(defmethod snap ((obj repeat) (backobj digital) angle)  (if (top? angle)    (snap-to obj backobj (bot-target backobj))    (if (left? angle)      (snap-to  obj backobj (right-repeat-target backobj))      (if (bottom? angle)        (snap-to obj backobj (top-repeat-target backobj))))))(defmethod snap ((obj repeat) (backobj analog) angle)  (if (top? angle)    (snap-to obj backobj (bot-target backobj))    (if (bottom? angle)      (snap-to obj backobj (top-repeat-target backobj)))))(defmethod snap ((obj repeat) (backobj action-input) angle)  (if (top? angle)    (snap-to obj backobj (bot-target backobj))    (if (botright? angle)      (snap-to obj backobj (left-func-target backobj))      (if (bottom? angle)        (snap-to obj backobj (top-repeat-target backobj))))))(defmethod snap ((obj repeat) (backobj proc) angle)  (if (top? angle)    (snap-to obj backobj (bot-repeat-target backobj))    (if (left? angle)      (snap-to obj backobj (right-repeat-target backobj))      (if (botright? angle)        (snap-to  obj backobj (left-func-target backobj))        (if (bottom? angle)          (snap-to obj backobj (top-repeat-target backobj)))))))(defmethod snap ((obj repeat) (backobj repeat) angle)  (if (top? angle)    (snap-to obj backobj (bot-target backobj))    (if (topleft? angle)      (snap-to obj backobj (func-target backobj))      (if (bottom? angle)        (snap-to obj backobj (top-repeat-target backobj))))))(defmethod snap ((obj repeat) (backobj number-var) angle)  (if (topright? angle)    (snap-to obj backobj (right-num-target backobj))    (if (left? angle)      (snap-to obj backobj (right-repeat-target backobj)))))(defmethod snap ((obj repeat) (backobj object) angle)  ());--------------- DIGITAL SENSOR OBJECT -----------------------------------------(defvar digital-region)(defun init-digital ()  (unless standalone? (my-open-resource-file "home:visual-logo-resources"))  (let ((digital-pict (my-get-resource "PICT" "digital")))    (unless standalone?       (my-close-resource-file))    (setf digital-region (get-region-from-pict digital-pict))))  (defun make-digital (name color-list definition location)  (let* ((boundrgn (copy-region digital-region))         (boundrect (bound-region-rect boundrgn)))    (move-rect boundrect location)    (move-region boundrgn location)    (let ((obj (make-instance 'digital                 :name name                 :color-list color-list                 :definition definition                 :currentdef (car definition)                 :boundrect boundrect                 :boundrgn boundrgn)))      obj))) (defmethod copy-obj ((obj digital))  (make-digital (name obj) (color-list obj) (definition obj)                (topleft (boundrect obj))))(defmethod draw-object ((obj digital) grafport)  (draw-digital (boundrect obj)                 (boundrgn obj) (color-list obj)                (symbol-name (currentdef obj))                (selected? obj)));;; then draw the text(defun draw-digital (boundrect boundrgn color-list definition selected?)  (with-fore-color (if selected? *gray-color*                       (car color-list))    (#_paintrgn boundrgn))  (let ((xpos (+ -1 (left boundrect) (- (truncate (/ (rect-width boundrect) 2))                                     (truncate (/ (string-width definition) 2)))))        (ypos (+ (top boundrect) 17)))    (#_moveto xpos ypos)    (with-fore-color (cadr color-list)      (with-pstrs ((string definition))        (#_Drawstring string)))))(defmethod erase-object ((obj digital) grafport)  (erase-digital (boundrgn obj)))(defun erase-digital (boundrgn)  (#_erasergn boundrgn))(defmethod save-object ((obj digital))  (Append (list 'digital                (name obj)                (car (color-list obj))                (cadr (color-list obj))                (topleft (boundrect obj)))          (definition obj)));;; getting info to recreate a digital box;;; same order as the saved list, but all in string format(defun recreate-digital (list-of-traits)  (let* ((name (pop list-of-traits))         (color-list (list (parse-integer (pop list-of-traits))                           (parse-integer (pop list-of-traits))))         (topleft (parse-integer (pop list-of-traits)))         (definition (loop while (not (null list-of-traits))                           collect (read-from-string (pop list-of-traits)))))    (make-digital name color-list definition topleft)))(defmethod snap-objs ((obj digital) list-of-objs)  (rlet ((rect :rect :topleft #@(0 0) :botright #@(0 0)))    (let ((temp-rect (copy-rect (boundrect obj))))      (inset-rect temp-rect -3 -3)      (loop for backobj in list-of-objs            unless (equal backobj obj)            do (intersect-rect temp-rect (boundrect backobj) rect)            and unless (empty-rect-p rect)            do (let ((angle (point-to-angle (boundrect obj)                                               (center-rect (boundrect backobj)))))                 (snap obj backobj angle)))      (dispose-record temp-rect))))(defmethod snap ((obj digital) (backobj action) angle)  (snap-box obj backobj angle))(defmethod snap ((obj digital) (backobj digital) angle)  (snap-box obj backobj angle))(defmethod snap ((obj digital) (Backobj analog) angle)  (snap-box-not-left obj backobj angle))(defmethod snap ((obj digital) (backobj action-input) angle)  (snap-box-not-left obj backobj angle))(defmethod snap ((obj digital) (backobj proc) angle)  (snap-box-proc-all obj backobj angle))(defmethod snap ((obj digital) (backobj repeat) angle)  (snap-box-not-left obj backobj angle))(defmethod snap ((obj digital) (backobj number-var) angle)  (if (left? angle)    (snap-to obj backobj (right-target backobj)))); ------------- Analog Sensor ---------------------(defvar analog-region)(defun init-analog ()  (unless standalone? (my-open-resource-file "home:visual-logo-resources"))  (let ((analog-pict (my-get-resource "PICT" "analog")))    (unless standalone?       (my-close-resource-file))    (setf analog-region (get-region-from-pict analog-pict))))  (defun make-analog (name color-list definition relation location)  (let* ((boundrgn (copy-region analog-region))         (boundrect (bound-region-rect boundrgn)))    (move-rect boundrect location)    (move-region boundrgn location)    (let ((obj (make-instance 'analog                 :name name                 :color-list color-list                 :definition definition                 :relation relation                 :currentdef (car definition)                 :currentrel (car relation)                 :boundrect boundrect                 :boundrgn boundrgn                 :num-target #@(33 3))))      obj))) (defmethod copy-obj ((obj analog))  (make-analog (name obj) (color-list obj) (definition obj)               (relation obj) (topleft (boundrect obj))))(defmethod draw-object ((obj analog) grafport)  (draw-analog (boundrect obj)                 (boundrgn obj) (color-list obj)                (symbol-name (currentdef obj))                (symbol-name (currentrel obj))                (selected? obj)));;; then draw the text(defun draw-analog (boundrect boundrgn color-list definition relation selected?)  (with-fore-color (if selected? *gray-color*                       (car color-list))    (#_paintrgn boundrgn))  (let ((text-length (string-width definition)))    (let ((xpos (+ 4 (left boundrect)))           (ypos (+ (top boundrect) 17)))    (#_moveto xpos ypos)    (with-fore-color (cadr color-list)      (with-pstrs ((string definition))        (#_Drawstring string))      (#_moveto (+ xpos text-length (if (equal (length relation) 1)                                      3 1)) ypos)      (with-pstrs ((string relation))        (#_drawstring string))))))(defmethod erase-object ((obj analog) grafport)  (erase-analog (boundrgn obj)))(defun erase-analog (boundrgn)  (#_erasergn boundrgn))(defmethod change-definition-rel ((view interface-view) (obj analog))  (setf (relation obj) (append (cdr (relation obj))                               (list (first (relation obj)))))  (setf (currentrel obj) (car (relation obj)))  (draw view (list obj))  (view-draw-contents view)) (defmethod save-object ((obj analog))  (Append (list 'analog                (name obj)                (car (color-list obj))                (cadr (color-list obj))                (topleft (boundrect obj))                (currentrel obj))          (definition obj)));;; getting info to recreate an analog box;;; same order as the saved list, but all in string format(defun recreate-analog (list-of-traits)  (let* ((name (pop list-of-traits))         (color-list (list (parse-integer (pop list-of-traits))                           (parse-integer (pop list-of-traits))))         (topleft (parse-integer (pop list-of-traits)))         (relation (read-from-string (pop list-of-traits)))         (definition (loop while (not (null list-of-traits))                           collect (read-from-string (pop list-of-traits)))))    ;;wow what a hack    (let ((relations (cond ((eq relation '<) '(< > =))                           ((eq relation '>) '(> = <))                           ((eq relation '=) '(= < >)))))      (make-analog name color-list definition relations topleft))))(defmethod snap-objs ((obj analog) list-of-objs)  (rlet ((rect :rect :topleft #@(0 0) :botright #@(0 0)))    (let ((temp-rect (copy-rect (boundrect obj))))      (inset-rect temp-rect -3 -3)      (loop for backobj in list-of-objs            unless (equal backobj obj)            do (intersect-rect temp-rect (boundrect backobj) rect)            and unless (empty-rect-p rect)            do (let ((angle (point-to-angle (boundrect obj)                                               (center-rect (boundrect backobj)))))                 (snap obj backobj angle)))      (dispose-record temp-rect))))(defmethod snap ((obj analog) (backobj action) angle)  (snap-box-not-right obj backobj angle))(defmethod snap ((obj analog) (backobj digital) angle)  (snap-box-not-right obj backobj angle))(defmethod snap ((obj analog) (backobj action-input) angle)  (snap-box-not-right-or-left obj backobj angle))(defmethod snap ((obj analog) (backobj analog) angle)  (snap-box-not-right-or-left obj backobj angle))(defmethod snap ((obj analog) (backobj proc) angle)  (snap-box-proc-not-right obj backobj angle))(defmethod snap ((obj analog) (backobj repeat) angle)  (snap-box-not-right-or-left obj backobj angle))(defmethod snap ((obj analog) (backobj number-var) angle)  (if (right? angle)    (snap-to obj backobj (right-num-target backobj))    (if (left? angle)      (snap-to obj backobj (right-target backobj)))));-------------- NUMBER VARIABLE ------------------------------(defvar number-region-left)(defvar number-region-right);; load up the picts from the resource file;; then get their regions and store them. That's all we want.(defun init-number-var ()  (unless standalone?     (my-open-resource-file "home:visual-logo-resources"))  (let ((number-pict-left (my-get-resource "PICT" "bignum-left"))        (number-pict-right (my-get-resource "PICT" "bignum-right")))    (unless standalone?       (my-close-resource-file))    (setf number-region-left (get-region-from-pict number-pict-left))    (setf number-region-right (get-region-from-pict number-pict-right))))  (defun make-number-var (name color-list definition location orient)  (let* ((boundrgn (if (eq orient 'left)                    (copy-region number-region-left)                    (copy-region number-region-right)))         (boundrect (bound-region-rect boundrgn)))    (move-rect boundrect location)    (move-region boundrgn location)    (let ((obj (make-instance 'number-var                 :name name                 :color-list color-list                 :definition definition                 :currentdef definition                 :boundrect boundrect                 :boundrgn boundrgn                 :orient orient                 :right-num-target #@(-33 -3)                 :left-num-target #@(-29 3)                 :left-proc-target #@(-29 4)                 :right-proc-target #@(29 -4)                 :left-repeat-target #@(-29 18)                 :right-target #@(29 -3)                 :right-repeat-target #@(29 -18))))      obj)))             (defmethod copy-obj ((obj number-var))  (make-number-var (name obj) (color-list obj) (definition obj)                   (topleft (boundrect obj)) (orient obj)))(defmethod change-definition ((view interface-view) (obj number-var) where)  (declare (ignore where))  (if (= (definition obj) 255)     (setf (definition obj) 1)    (setf (definition obj) (1+ (definition obj))))  (setf (currentdef obj) (definition obj))  (draw view (list obj))  (view-draw-contents view))(defmethod change-definition-byten ((view interface-view) (obj number-var))  (if (> (definition obj) 245)     (setf (definition obj) (- (definition obj) 245))    (setf (definition obj) (+ 10 (definition obj))))  (setf (currentdef obj) (definition obj))  (draw view (list obj))  (view-draw-contents view))(defmethod draw-object ((obj number-var) grafport)  (draw-number-var (boundrect obj) (boundrgn obj)                    (color-list obj)                   (format nil "~A" (currentdef obj))                   (selected? obj)));;; then draw the text(defun draw-number-var (boundrect boundrgn color-list definition selected?)  (with-fore-color (if selected? *gray-color*                       (car color-list))    (#_paintrgn boundrgn))  (let ((xpos (+ 4 (left boundrect) (- (truncate (/ (rect-width boundrect) 2))                                        (truncate (/ (string-width definition) 2)))))        (ypos (+ (top boundrect) 14)))    (#_moveto xpos ypos)    (with-fore-color (cadr color-list)      (with-pstrs ((string definition))        (#_Drawstring string)))))(defmethod erase-object ((obj number-var) grafport)  (erase-number-var (boundrgn obj)))(defun erase-number-var (boundrgn)  (#_erasergn boundrgn))(defmethod save-object ((obj number-var))  (list 'number-var         (name obj)        (car (color-list obj))        (Cadr (Color-list obj))        (definition obj)        (topleft (boundrect obj))        (orient obj)));;; getting info to recreate an action-box;;; same order as the saved list, but all in string format(defun recreate-number-var (list-of-traits)  (let* ((name (pop list-of-traits))         (color-list (list (parse-integer (pop list-of-traits))                           (parse-integer (pop list-of-traits))))         (definition (parse-integer (pop list-of-traits)))         (topleft (parse-integer (pop list-of-traits)))         (orient (read-from-string (pop list-of-traits))))    (make-number-var name color-list definition topleft orient)));;; numbers want to snap into action-input blocks and repeat blocks.;;; if a number-var region intersects the rectangle of the right side of a;;; action-input block or a repeat block, it will snap into place.(defmethod snap-objs ((obj number-var) list-of-objs)  (rlet ((rect :rect :topleft #@(0 0) :botright #@(0 0)))    (let ((temp-rect (copy-rect (boundrect obj))))      (inset-rect temp-rect -3 -3)      (loop for backobj in list-of-objs            unless (equal backobj obj)            do (intersect-rect temp-rect (boundrect backobj) rect)            and unless (empty-rect-p rect)            do (let ((angle (point-to-angle (boundrect obj)                                             (center-rect (boundrect backobj)))))                 (snap obj backobj angle)))      (dispose-record temp-rect))))(defmethod snap ((obj number-var) (backobj action-input) angle)  (if (left? angle) ;the number is on the right of the backobj    (snap-to obj backobj (num-target backobj))    (if (right? angle)       (snap-to obj backobj (left-num-target obj)))))(defmethod snap ((obj number-var) (backobj analog) angle)  (if (left? angle) ;the number is on the right of the backobj    (snap-to obj backobj (num-target backobj))    (if (right? angle)       (snap-to obj backobj (left-num-target obj)))))(defmethod snap ((obj number-var) (backobj repeat) angle)  (if (botleft? angle) ;the number is on the right of the backobj    (snap-to obj backobj (num-target backobj))    (if (right? angle)      (snap-to obj backobj (left-repeat-target obj)))))(defmethod snap ((obj number-var) (backobj action) angle)  (when (right? angle)     (snap-to obj backobj (left-num-target obj))))(defmethod snap ((obj number-var) (backobj digital) angle)  (when (right? angle)     (snap-to obj backobj (left-num-target obj))))(defmethod snap ((obj number-var) (backobj proc) angle)  (when (right? angle)    (snap-to obj backobj (left-proc-target obj))));--------------------- PROC OPERATIONS ------------------------------(defvar folder-region-list nil)(defvar folder-pict-list nil)(defvar folder-define-pict-list nil)(defvar folder-offscreen)(defun init-proc ()  (unless standalone? (my-open-resource-file "home:visual-logo-resources"))  (push (my-get-resource "PICT" "folder-7") folder-pict-list)  (push (my-get-resource "PICT" "folder-6") folder-pict-list)  (push (my-get-resource "PICT" "folder-5") folder-pict-list)  (push (my-get-resource "PICT" "folder-4") folder-pict-list)  (push (my-get-resource "PICT" "folder-3") folder-pict-list)  (push (my-get-resource "PICT" "folder-2") folder-pict-list)  (push (my-get-resource "PICT" "folder-1") folder-pict-list)  (push (my-get-resource "PICT" "folder-7-define") folder-define-pict-list)  (push (my-get-resource "PICT" "folder-6-define") folder-define-pict-list)  (push (my-get-resource "PICT" "folder-5-define") folder-define-pict-list)  (push (my-get-resource "PICT" "folder-4-define") folder-define-pict-list)  (push (my-get-resource "PICT" "folder-3-define") folder-define-pict-list)  (push (my-get-resource "PICT" "folder-2-define") folder-define-pict-list)  (push (my-get-resource "PICT" "folder-1-define") folder-define-pict-list)  (unless standalone? (my-close-resource-file))  (push (get-region-from-pict (nth 6 folder-pict-list)) folder-region-list)  (push (get-region-from-pict (nth 5 folder-pict-list)) folder-region-list)  (push (get-region-from-pict (nth 4 folder-pict-list)) folder-region-list)  (push (get-region-from-pict (nth 3 folder-pict-list)) folder-region-list)  (push (get-region-from-pict (nth 2 folder-pict-list)) folder-region-list)  (push (get-region-from-pict (nth 1 folder-pict-list)) folder-region-list)  (push (get-region-from-pict (nth 0 folder-pict-list)) folder-region-list)  (let* ((boundrect (bound-rect-pict (first folder-pict-list)))         (temp-window (make-instance 'window                        :color-p t                        :view-size (rect-size boundrect)                        :window-show nil)))    (setf folder-offscreen (make-offscreen-gworld temp-window))    (offscreen folder-offscreen (#_eraserect boundrect))    (window-close temp-window)    (dispose-record boundrect)))                   (defun make-proc (name definition def? location)  (let* ((boundrgn (copy-region (nth (first definition) folder-region-list)))         (boundrect (bound-region-rect boundrgn)))    (move-rect boundrect location)    (move-region boundrgn location)    (let ((alt-rect (copy-rect boundrect)))      (move-rect alt-rect #@(0 0))      (offscreen folder-offscreen                  (#_drawpicture (nth (first definition) folder-pict-list) alt-rect))      (dispose-record alt-rect))    (let ((obj (make-instance 'proc                 :name name                 :proc-name (car name)                 :definition definition                 :currentdef (Car definition)                 :boundrect boundrect                 :boundrgn boundrgn                 :define? def?                 :bot-proc-target #@(0 25)                 :top-proc-target #@(0 -25)                 :right-target #@(31 0)                 :left-proc-target #@(-31 0)                 :bot-repeat-target #@(-9 25)                 :top-repeat-target #@(-9 -55)                 :right-repeat-target #@(31 -14)                 :left-func-target #@(-32 -26)                 :top-action-target #@(-9 -26))))      obj))) (defmethod copy-obj ((obj proc))  (make-proc (name obj) (definition obj)              (define? obj) (topleft (boundrect obj))))(defmethod draw-object ((obj proc) grafport)  (draw-proc (boundrect obj) (boundrgn obj) (currentdef obj)             (define? obj) (selected? obj) grafport));; this should be a copybits from an offscreen. (defun draw-proc (boundrect boundrgn pict-num define? selected? grafport)  (let ((alt-rect (copy-rect boundrect)))    (move-rect alt-rect #@(0 0))    (offscreen folder-offscreen                (#_drawpicture (nth pict-num (if define?                                               folder-define-pict-list                                               folder-pict-list))                alt-rect))    (#_copybits (pref folder-offscreen :Grafport.portbits)     (pref grafport :grafport.portbits)     alt-rect boundrect (if selected? 4 0) boundrgn)    (dispose-record alt-rect)))(defmethod erase-object ((obj proc) grafport)  (erase-proc (boundrgn obj)))(defun erase-proc (boundrgn)  (#_erasergn boundrgn))(defmethod change-definition ((view interface-view) (obj proc) where)  (declare (ignore where));  (erase view (list obj))  (dispose-region (boundrgn obj))  (if (= (currentdef obj) 6)    (progn       (setf (boundrgn obj) (move-region (copy-region (first folder-region-list))                                        (topleft (boundrect obj))))      (setf (currentdef obj) 0))    (progn      (setf (boundrgn obj) (move-region (copy-region (nth (1+ (currentdef obj)) folder-region-list))                                        (topleft (boundrect obj))))      (setf (currentdef obj) (1+ (currentdef obj)))))  (setf (definition obj) (append (cdr (Definition obj))                                  (list (car (definition obj)))))  (setf (name obj) (append (cdr (name obj)) (list (Car (name obj)))))  (setf (proc-name obj) (car (name obj)))  (let ((alt-rect (copy-rect (boundrect obj))))    (move-rect alt-rect #@(0 0))    (offscreen folder-offscreen               (#_drawpicture (nth (currentdef obj) (if (define? obj)                                                        folder-define-pict-list                                                        folder-pict-list))                alt-rect))    (dispose-record alt-rect))  (draw view (list obj))  (view-draw-contents view))(defmethod change-definition-define ((View interface-view) (obj proc))  (setf (define? obj) (not (define? obj)))  (let ((alt-rect (copy-rect (boundrect obj))))    (move-rect alt-rect #@(0 0))    (offscreen folder-offscreen               (#_drawpicture (nth (currentdef obj) (if (define? obj)                                                      folder-define-pict-list                                                      folder-pict-list))                alt-rect))    (dispose-record alt-rect))  (draw view (list obj))  (view-draw-contents view))(defmethod save-object ((obj proc))  (append (list 'proc                (define? obj)                (topleft (boundrect obj)))          (name obj)          (definition obj)));;; getting info to recreate a proc object;;; same order as the saved list, but all in string format(defun recreate-proc (list-of-traits)  (let* ((define? (equal (pop list-of-traits) "T "))         (topleft (parse-integer (pop list-of-traits)))         (name            (loop for i from 1 to 7                 collect (Read-from-string (pop list-of-traits))))         (definition           (loop for i from 1 to 7                 collect (parse-integer (pop list-of-traits)))))    (make-proc name definition define? topleft)))(defmethod snap-objs ((obj proc) list-of-objs)    (rlet ((rect :rect :topleft #@(0 0) :botright #@(0 0)))      (let ((temp-rect (copy-rect (boundrect obj))))        (inset-rect temp-rect -3 -3)        (loop for backobj in list-of-objs              unless (equal backobj obj)              do (intersect-rect temp-rect (boundrect backobj) rect)              and unless (empty-rect-p rect)              do (let ((angle (point-to-angle (boundrect obj)                                               (center-rect (boundrect backobj)))))                   (snap obj backobj angle)))        (dispose-record temp-rect))))(defmethod snap ((obj proc) (backobj action) angle)  (snap-box-proc obj backobj angle))(defmethod snap ((obj proc) (backobj digital) angle)  (snap-box-proc obj backobj angle))(defmethod snap ((obj proc) (backobj analog) angle)  (snap-box-proc-not-left obj backobj angle))(defmethod snap ((obj proc) (backobj action-input) angle)  (snap-box-proc-not-left obj backobj angle))(defmethod snap ((obj proc) (backobj proc) angle)  (snap-box-proc obj backobj angle))(defmethod snap ((obj proc) (backobj repeat) angle)  (if (top? angle)    (snap-to obj backobj (bot-proc-target backobj))    (if (bottom? angle)      (snap-to obj backobj (top-proc-target backobj))      (if (topleft? angle)        (snap-to obj backobj (func-target backobj))        (if (right? angle)          (snap-to obj backobj (left-proc-target backobj)))))))(defmethod snap ((obj proc) (backobj number-var) angle)  (if (left? angle)    (snap-to obj backobj (right-proc-target backobj))))#|;----------------------- ROAD Analog Sensor ---------------------(defvar road-region)(defvar road-pict)(defvar road-offscreen)(defvar road-region)(defun init-road ()  (unless standalone? (my-open-resource-file "home:visual-logo-resources"))  (setf road-pict (my-get-resource "PICT" "road"))  (unless standalone? (my-close-resource-file))  (setf road-region (get-region-from-pict road-pict))  (let* ((boundrect (bound-rect-pict road-pict))         (temp-window (make-instance 'window                        :color-p t                        :view-size (rect-size boundrect)                        :window-show nil)))    (setf road-offscreen (make-offscreen-gworld temp-window))    (offscreen road-offscreen (#_eraserect boundrect))    (window-close temp-window)    (dispose-record boundrect)))(defun make-road (name definition location)  (let* ((boundrgn (copy-region road-region))         (boundrect (bound-region-rect boundrgn))         (middle-rect (inset-rect (copy-rect boundrect) 65 0))         (up-zone-rect (make-record :rect :topleft #@(0 0)                                     :botright (make-point 65 (rect-height boundrect))))         (down-zone-rect (make-record :rect :topleft #@(66 0)                                     <:botright (make-point (rect-width boundrect)                                                          (rect-height boundrect)))))    (move-rect boundrect location)    (move-region boundrgn location)    (let ((alt-rect (copy-rect boundrect)))      (move-rect alt-rect #@(0 0))      (offscreen road-offscreen                  (#_drawpicture road-pict alt-rect))      (dispose-record alt-rect))    (let ((obj (make-instance 'road                 :name name                 :definition definition                 :currentdef (Car definition)                 :boundrect boundrect                 :boundrgn boundrgn                 :middle-rect middle-rect                 :up-zone-list (list up-zone-rect)                 :down-zone-list (list down-zone-rect))))      obj)))(defmethod copy-obj ((obj road))  (make-road (name obj) (definition obj) (topleft (boundrect obj))))(defmethod draw-object ((obj road) grafport)  (draw-road (boundrect obj) (boundrgn obj) (selected? obj) grafport)  (draw-edges (boundrect obj) (up-edge-list obj) (down-edge-list obj)))(defun draw-road (boundrect boundrgn selected? grafport)  (let ((alt-rect (copy-rect boundrect)))    (move-rect alt-rect #@(0 0))    (#_copybits (pref road-offscreen :Grafport.portbits)     (pref grafport :grafport.portbits)     alt-rect boundrect (if selected? 4 0) boundrgn)    (dispose-record alt-rect))); car is ycor, cdr is sensor-value(defun draw-edges (boundrect up-list down-list)  (with-fore-color *red-color*    (loop for edge in up-list do          (let ((origtopleft (topleft (boundrect edge))))            (move-rect (boundrect edge) (+ (topleft boundrect) origtopleft))            (#_paintrect (boundrect edge))            (move-rect (boundrect edge) origtopleft)))    (loop for edge in down-list do          (let ((origtopleft (topleft (Boundrect edge))))            (move-rect (boundrect edge) (+ (topleft boundrect) origtopleft))            (#_paintrect (boundrect edge))            (move-rect (Boundrect edge) origtopleft)))))(defmethod erase-object ((obj road) grafport)  (erase-road (boundrgn obj)))(defun erase-road (boundrgn)  (#_erasergn boundrgn))(defmethod delete-object ((obj road))  (loop for edge in (up-edge-list obj) do        (dispose-record (boundrect edge)))  (loop for edge in (down-edge-list obj) do        (dispose-record (boundrect edge)))  (dispose-record (middle-rect obj)));;; roads are divided (Defmethod change-definition ((view interface-view) (obj road) where)  (let ((local (subtract-points where (topleft (boundrect obj)))))    ;; figure out which side we're on    (let ((side (if (< (point-h local) (/ (rect-width (boundrect obj)) 2))                  'down                   'up)))      (add-edge view obj side (point-v local))      (Eval-enqueue (progn                       (draw view (list obj))                      (view-draw-contents view))))))(defmethod change-definition-off ((View interface-view) (obj road) where)  (push-to-back (page view) obj)  (let ((local (subtract-points where (topleft (boundrect obj)))))    ;; figure out which side we're on    (let ((side (if (> (point-h local) (/ (rect-width (boundrect obj)) 2))                  'up 'down)))      (let ((foo (Remove-edge view obj local                              (if (equal side 'up) (up-edge-list obj)                                  (down-edge-list obj)))))        (unless (numberp foo)          (if (equal side 'up)             (setf (up-edge-list obj) foo)            (setf (down-edge-list obj) foo))          (draw view (list obj))          (view-draw-contents view))))))(defmethod add-edge ((view interface-view) (obj road) side ycor)  (let ((sensor-value (convert-ycor-to-sensor-value (rect-height (Boundrect obj))                                                    ycor)))    (if (equal side 'down)      (let ((rect (make-record :rect :top ycor :left 5                               :bottom (+ ycor 4)                               :right (- (floor (/ (rect-width (boundrect obj)) 2))                                         2))))        (add-edge-to-list obj (make-instance 'edge                             :boundrect rect                            :sensor-value sensor-value)                           'down)        (print (down-edge-list obj))        (make-zone-list obj 'down))      (let ((rect (make-record :rect :top ycor                                :left (+ 3 (ceiling (/ (Rect-width (boundrect obj)) 2)))                               :bottom (+ ycor 4)                                :right (- (rect-width (boundrect obj)) 5))))        (add-edge-to-list obj (make-instance 'edge                             :boundrect rect                            :sensor-value sensor-value)                           'up)        (print (up-edge-list obj))        (make-zone-list obj 'up)))))(defmethod add-edge-to-list ((obj road) (e edge) side)  (if (equal side 'up)    (let ((pos 0))      (loop for edge in (up-edge-list obj)            for i from 1            when (>= (sensor-value e) (sensor-value edge))            do (setf pos i))      (print pos)      (push e (nthcdr pos (up-edge-list obj))))    (let ((pos 0))      (loop for edge in (down-edge-list obj)            for i from 1            when (>= (sensor-value e) (sensor-value edge))            do (setf pos i))      (print pos)      (push e (nthcdr pos (down-edge-list obj))))))   (defmethod make-zone-list ((obj road) side))    (defmethod remove-edge ((view interface-view) (obj road) local list-to-modify)  (loop for edge in list-to-modify         when (point-in-rect-p (boundrect edge) local)        do (setf list-to-modify (reverse (set-difference                                           list-to-modify                                           (list edge))))        (return list-to-modify)        finally return -1)); sensor is from 0 to 255, ycor is from 0 to height(defun convert-ycor-to-sensor-value (height ycor)  (* 256 (/ ycor height))) (defmethod save-object ((obj road))  (append (list 'road                (topleft (boundrect obj)))          (name obj)          (definition obj)));;; getting info to recreate a road object;;; same order as the saved list, but all in string format(defun recreate-road (list-of-traits)  (let* ((topleft (parse-integer (pop list-of-traits)))         (name (read-from-string (pop list-of-traits)))         (definition (read-from-string (pop list-of-traits))))    (make-road name definition topleft)))(defmethod pre-move ((view main) (obj road))  (push-to-back (page view) obj))                   |#;--------------- UTILS --------------------------------------;;; Basically, I want to load the pict into a handle, then draw it on;;; the screen. I then want to use seedcfill to fill the area around the;;; picture, and then grab that bitmap, invert it, and do bitmap-to-region;;; and voila. I've got it.(defun load-pict ()  (let ((file (choose-file-dialog)))    (unless (equal file 'cancelled)      (let ((h (#_newhandle 0)))        (with-open-file (s file :direction :input )          (let ((l (- (file-length s) 512)))            (#_sethandlesize h l)            (dotimes (i 512)(stream-tyi s))            (dotimes (i l)(%hput-byte h (char-code (stream-tyi s)) i))))        h))))(defun do-seed-fill (offscreen h)  (let ((boundrect (bound-rect-pict h)))    (let ((dstbits (make-bitmap boundrect))          (srcbits (pref offscreen :grafport.portbits))          (reg (new-region)))      (with-rgb (color *white-color*)        (#_calccmask srcbits dstbits boundrect boundrect color (%null-ptr) 0)        ;(#_seedcfill srcbits dstbits boundrect boundrect 0 0 (%null-ptr) 0)        ;;invert bitmap        (#_copybits dstbits dstbits boundrect boundrect 4 (%null-ptr))        (#_bitmaptoregion reg dstbits)        (dispose-record dstbits)        (dispose-record boundrect)        reg))));; first we need an offscreen the same size as the pict, then we;; do a seed fill and grab the region.  (defun get-region-from-pict (pict)  (let* ((boundrect (bound-rect-pict pict))         (temp-window (make-instance 'window                        :color-p t                        :view-size (rect-size boundrect)                        :window-show nil))         (gworld (make-offscreen-gworld temp-window)))    (offscreen gworld (#_drawpicture pict boundrect))    (let ((reg (do-seed-fill gworld pict)))      (#_disposegworld gworld)      (window-close temp-window)      (dispose-record boundrect)      reg)))
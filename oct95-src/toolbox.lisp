;;;; Random ToolBOX shit. (12/9/94);;;; RANDOM FUNCS(defmacro top (rect)  `(pref ,rect :rect.top))(defmacro right (rect)  `(pref ,rect :rect.right))(defmacro left (rect)  `(pref ,rect :rect.left))(defmacro bottom (rect)  `(pref ,rect :rect.bottom))(defmacro topleft (rect)  `(pref ,rect :rect.topleft))(defmacro botright (rect)  `(pref ,rect :rect.botright))(defun topright (rect)  (make-point (right rect) (top rect)))(defun botleft (rect)  (make-point (left rect) (bottom rect)))(defun rect-width (rect)  (- (right rect) (left rect)))(defun rect-height (rect)  (- (bottom rect) (top rect)))(defun rect-size (rect)  (subtract-points (botright rect) (topleft rect)))(defun center-rect (rect)  (add-points (topleft rect)              (make-point (round (/ (rect-width rect) 2))                          (round (/ (rect-height rect) 2)))))(defun rect-equal (rect1 rect2)  (and (equal (topleft rect1) (topleft rect2))       (equal (botright rect1) (botright rect2))))(defun copy-rect (rect)  (make-record :rect :topleft (topleft rect) :botright (botright rect)))(defun ncopy-rect (rect rect-dest)  (setf (topleft rect-dest) (topleft rect))  (Setf (botright rect-dest) (botright rect)));returns the destructively modified rectangle(defun move-rect (rect h &optional v)  (when v (setf h (make-point h v)))  (let ((size (rect-size rect)))    (setf (topleft rect) h)    (setf (botright rect) (add-points h size)))  rect)(defun move-region (region h &optional v)  (when v (Setf h (make-point h v)))  (with-dereferenced-handles ((reg region))    (let ((size-rect (rref reg :region.rgnbbox :storage :pointer)))      (offset-region region (subtract-points h (topleft size-rect)))))  region)(defun bound-region-rect (region)  (with-dereferenced-handles ((reg region))    (let ((size-rect (rref reg :region.rgnbbox :storage :pointer)))      (copy-rect size-rect))))(defun ascent (font-name font-size)  (multiple-value-bind (ascent descent maxwidth leading)                       (font-info (list font-name font-size))    (declare (ignore descent leading maxwidth))    ascent))(defun descent (font-name font-size)  (multiple-value-bind (ascent descent maxwidth leading)                       (font-info (list font-name font-size))    (declare (ignore ascent leading maxwidth))    descent));; this works on any anchor corner;; anchor is a (list 'corner point) where corner is topleft, topright, botleft, botright;; if horz is true, resize can happen horizontally;; if vert is true, resize can happen vertically.(defmethod drag-resize-gray-rect ((view view) where bound-rect anchor horz vert)  ;; figure out the corner we're dragging  ;; then branch into that quadrant for dragging  ;; then loop  ;; anchor is a (list 'corner point)  (unless (and (not horz) (not vert))    (without-interrupts     (let ((prev-mouse-point where)           (old-pen-pattern (pen-pattern view))           (old-pen-mode (pen-mode view)))       (set-pen-pattern view *gray-pattern*)       (set-pen-mode view :patXor)       (with-focused-view view          (frame-rect view bound-rect)         (loop while (mouse-down-p) do               (let ((temp-pos (View-mouse-position view)))                 (let ((quad (which-quadrant? anchor temp-pos)))                    (unless (if (and horz vert)                             (equal prev-mouse-point temp-pos)                             (if horz                               (equal (point-h prev-mouse-point) (point-h temp-pos))                               (equal (point-v prev-mouse-point) (point-v temp-pos))))                     (frame-rect view bound-rect)                     (let ((change-quad?                             (inside-quadrant-update anchor quad bound-rect temp-pos horz vert)))                        (when change-quad? ;; if yes, reassert the whole bound-rect to prevent slipping                         (setf anchor (reassert-rectangle anchor quad bound-rect temp-pos horz vert)))                       (frame-rect view bound-rect))))                 (setf prev-mouse-point temp-pos))))       (frame-rect view bound-rect)       (set-pen-pattern view old-pen-pattern)       (set-pen-mode view old-pen-mode)       bound-rect))))  ;;; returns change-quad?;;; modifies bound-rect(defun inside-quadrant-update (anchor quad bound-rect temp-pos horz vert)  (let ((change-quad? nil))    (case (car anchor)       (topleft (if (equal quad 'botright)                  (progn                   (when horz (rset bound-rect :rect.right (point-h temp-pos)))                   (when vert (rset bound-rect :rect.bottom (point-v temp-pos))))                 (setf change-quad? t)))      (topright (if (equal quad 'botleft)                  (progn                    (when horz (rset bound-rect :rect.left (point-h temp-pos)))                    (when vert (rset bound-rect :rect.bottom (point-v temp-pos))))                  (setf change-quad? t)))      (botleft (if (equal quad 'topright)                 (progn                   (when horz (rset bound-rect :rect.right (point-h temp-pos)))                   (when vert (rset bound-rect :rect.top (point-v temp-pos))))                 (setf change-quad? t)))      (botright (if (equal quad 'topleft)                  (progn                    (when horz (rset bound-rect :rect.left (point-h temp-pos)))                    (when vert (rset bound-rect :rect.top (point-v temp-pos))))                  (setf change-quad? t))))    change-quad?));;; modifies bound-rect;;; returns new-anchor(defun reassert-rectangle (anchor quad bound-rect temp-pos horz vert)  (let ((new-anchor anchor))    (case quad      (topleft (progn                 (when horz                    (rset bound-rect :rect.left (point-h temp-pos))                   (rset bound-rect :rect.right (point-h (cadr anchor))))                 (when vert                   (rset bound-rect :rect.top (point-v temp-pos))                   (rset bound-rect :rect.bottom (point-v (cadr anchor))))                 (setf new-anchor (list 'botright (pref bound-rect :rect.botright)))))      (topright (progn                  (when horz                     (rset bound-rect :rect.right (point-h temp-pos))                    (rset bound-rect :rect.left (point-h (cadr anchor))))                  (when vert                    (rset bound-rect :rect.top (point-v temp-pos))                    (rset bound-rect :rect.bottom (point-v (cadr anchor))))                  (setf new-anchor (list 'botleft                                          (make-point (pref bound-rect :rect.left)                                                     (pref bound-rect :rect.bottom))))))      (botleft (progn                 (when horz                   (rset bound-rect :rect.left (point-h temp-pos))                   (rset bound-rect :rect.right (point-h (cadr anchor))))                 (when vert                   (rset bound-rect :rect.bottom (point-v temp-pos))                   (rset bound-rect :rect.top (point-v (cadr anchor))))                 (setf new-anchor (list 'topright                                        (make-point (pref bound-rect :rect.right)                                                    (pref bound-rect :rect.top))))))      (botright (progn                  (when horz                     (rset bound-rect :rect.left (point-h (cadr anchor)))                    (rset bound-rect :rect.right (point-h temp-pos)))                  (when vert                    (rset bound-rect :rect.top (point-v (cadr anchor)))                    (rset bound-rect :rect.bottom (point-v temp-pos)))                  (setf new-anchor (list 'topleft (pref bound-rect :rect.topleft))))))    new-anchor))(defun which-quadrant? (anchor where)  (let ((anchor-point (cadr anchor)))    (cond ((point<= anchor-point where)           'botright)          ((point<= where anchor-point)           'topleft)          ((<= (point-h where) (point-h anchor-point))           'botleft)          ((<= (point-v where) (point-v anchor-point))           'topright))));; returns 'click or 'drag if the mouse action is a click or a drag(defmethod click-or-drag? ((view view) where)  (let ((cont-loop? t)        (click-or-drag 'click)        (current-time (#_tickcount))) ;tickcount has 60 clicks per second    (loop while (and cont-loop? (mouse-down-p)) do            (if (or (not (close? (view-mouse-position view) where))                    (> (- (#_tickcount) current-time) 30))                                  (progn                       (setf cont-loop? nil)                      (setf click-or-drag 'drag))))    click-or-drag))(defun close? (point1 point2)  (and (< (abs (- (point-h point1) (point-h point2))) 5)       (< (abs (- (point-v point1) (point-v point2))) 5)))(defmethod draw-pict-xy ((view simple-view) pict h &optional v)  (when v (setf h (make-point h v)))  ;; get size as a rectangle  (let ((new-rect (bound-rect-pict pict)))    (offset-rect new-rect h)    (draw-picture view pict new-rect)    (dispose-record new-rect)))    ;;; this returns a new rect with the bounding-box of the rectangle(defun bound-rect-pict (pict)  (with-dereferenced-handles ((picture pict))    (let ((size-rect (rref picture :picture.picframe :storage :pointer)))      (copy-rect size-rect))));;;; OFFSCREEN GWORLD OPs;;; returns an offscreen-gworld(defmethod make-offscreen-gworld ((view simple-view) &optional rect)  (when (not rect) (setf rect (pref (Wptr view) :grafport.portrect)))  (with-focused-view view    (%stack-block ((result 4))      (#_NewGWorld result 0 rect (%null-ptr) (%null-ptr) 0)      (%get-ptr result))));;; form for doing an operation on the offscreen gworld(defmacro offscreen (offscreen-world &rest forms)  `(%stack-block ((ogd 4)(oport 4))     (#_lockpixels (#_getGworldPixmap ,offscreen-world))      (#_getgworld ogd oport)     (#_setgworld ,offscreen-world (%null-ptr))     (unwind-protect (progn ,@forms)       (#_setgworld (%get-ptr ogd)(%get-ptr oport))       (#_unlockpixels (#_getGworldPixmap ,offscreen-world)))))(defmethod copy-from-offscreen ((view simple-view) offscreen-gworld rect1                                &key (rect2 rect1) (rgn (%null-ptr)))  (with-focused-view view    (#_lockpixels (#_getgworldpixmap offscreen-gworld))    (#_copybits (%inc-ptr offscreen-gworld 2) (%inc-ptr (wptr view) 2)     rect1 rect2 0 rgn)    (#_unlockpixels (#_getgworldpixmap offscreen-gworld))))(defmethod copy-to-offscreen ((View simple-view) offscreen-gworld rect1                              &key (rect2 rect1) (rgn (%null-ptr)))  (%stack-block ((ogd 4)(oport 4))    (#_lockpixels (#_getGworldPixmap offscreen-gworld))     (#_getgworld ogd oport)    (#_setgworld offscreen-gworld (%null-ptr))    (#_copybits (%inc-ptr (wptr view) 2) (%inc-ptr offscreen-gworld 2)     rect1 rect2 0 rgn)    (#_setgworld (%get-ptr ogd)(%get-ptr oport))    (#_unlockpixels (#_getGworldPixmap offscreen-gworld))))(defmethod copy-offscreen-to-offscreen            (offscreen1 offscreen2 rect1 &key (rect2 rect1) (rgn (%null-ptr)))  (%stack-block ((ogd 4)(oport 4))    (#_lockpixels (#_getGworldPixmap offscreen1))    (#_lockpixels (#_getGworldPixmap offscreen2))     (#_getgworld ogd oport)    (#_setgworld offscreen1 (%null-ptr))    (#_copybits (%inc-ptr offscreen1 2) (%inc-ptr offscreen2 2)     rect1 rect2 0 rgn)    (#_setgworld (%get-ptr ogd)(%get-ptr oport))    (#_unlockpixels (#_getGworldPixmap offscreen2))    (#_unlockpixels (#_getGworldPixmap offscreen1))))(defvar *current-cursor-all* *Arrow-cursor*)(defvar *current-cursor-interface* *arrow-cursor*);;; NOTE: Cursors will only be active when the resource of the cursors is open. ;;; This will be true in the standalone version, or if the resources file is open.(defvar *pointing-hand* 256)(defvar *hand* 257)(defvar *pulling-hand* 258)(defvar *fist* 259)(defvar *abort-cursor* 512)(defvar *ne-sw-resize* 132)(defvar *nw-se-resize* 131)(defvar *n-s-resize* 130)(defvar *e-w-resize* 129)(defvar *watch* 4)(defvar *arrow* 0);(defmethod view-cursor ((view starlogo-view) point);  (declare (ignore point));  *current-cursor-all*);(defun change-cursor-all (cursor-number);  (setf *current-cursor-all* cursor-number);  (update-cursor));(defun change-cursor (cursor-number);  (setf *current-cursor-interface* cursor-number);  (update-cursor))(defmethod draw-icon-xy ((view simple-view) icon-handle copy-method cliprgn h &optional v)  (when v    (setf h (make-point h v)))  ;;use a copy of the icon-handle to avoid destroying it  (let ((temp-handle (copy-record icon-handle)))    (rlet ((dest-rect :rect :topleft h :botright (add-points #@(16 16) h)))      (#_hlock temp-handle)      (let ((icon (%get-ptr temp-handle))            (icon-bitmap (make-bitmap dest-rect)))        (rset icon-bitmap :bitmap.rowbytes 2)        (rset icon-bitmap :bitmap.baseaddr icon)        (#_Copybits icon-bitmap (pref (wptr view) :grafport.portbits)         (pref icon-bitmap :bitmap.bounds) dest-rect copy-method cliprgn)        (dispose-record icon-bitmap)        (dispose-record temp-handle)))))(defmethod draw-bitmap-xy ((View simple-view) bitmap copy-method cliprgn h &optional v)  (when v    (setf h (make-point h v)))  (rlet ((dest-rect :Rect :topleft h :botright (Add-points #@(16 16) h)))    (#_copybits bitmap (pref (Wptr view) :grafport.portbits)     (pref bitmap :bitmap.bounds) dest-rect copy-method cliprgn)));;; returns a bitmap record(defun make-bitmap-from-icon (icon-handle)  (#_hlock icon-handle)  (let ((temp-handle (copy-record icon-handle))        (int-rect (make-record :rect :topleft #@(0 0) :botright #@(16 16))))    (#_hlock temp-handle)    (let ((new-bitmap (make-record :bitmap :rowbytes 2 :bounds int-rect                                    :baseaddr (%get-ptr temp-handle))))      (#_hunlock icon-handle)      new-bitmap)))(defmacro with-clipped-region-in-view (view region &rest forms)  `(with-focused-view ,view     (let ((temp-region (clip-region ,view))           (temp-region1 (copy-region ,region)))       (intersect-region temp-region temp-region1 temp-region1)       (set-clip-region ,view temp-region1)       (progn ,@forms)       (set-clip-region ,view temp-region)       (dispose-region temp-region)       (dispose-region temp-region1))))
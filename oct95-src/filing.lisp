;;;; Filing and Menu Functions(defvar brick-logo-path nil)(defun file-open-dialog ()  (let ((old-brick-logo-path brick-logo-path))    (setq brick-logo-path (choose-file-dialog))    (if (eq brick-logo-path 'cancelled)      (setq brick-logo-path old-brick-logo-path) ;; restore the old path      (file-open brick-logo-path))))(defun file-open (path)  (setq brick-logo-path path)  (with-cursor *watch*    (with-open-file (input-stream path :direction :input)      (loop for p in (page-list (main *background*)) do            (delete-all-objects p))      (setf (page-list (main *background*)) nil)      (let ((saved-pages nil))        (let ((curpage (parse-integer (progn                                        (read-line input-stream nil 'eof)                                        (read-line input-stream nil 'eof)))))          (loop for i = (peek-char t input-stream nil 'eof)                until (equal i 'eof) do                (push (loop for i = (peek-char t input-stream nil 'eof)                            until (or (equal i #\@)                                      (equal i 'eof))                            collect (loop for i = (read-line input-stream nil 'eof)                                          until (or (equal i "@#$#@#$#@")                                                    (equal i "")                                                    (equal i 'eof))                                          collect i))                      saved-pages)                (read-line input-stream nil 'eof)) ;read the @#$#@#$#@ delimiter          (dotimes (i (length saved-pages))            (push (make-instance 'page :page-container (main *background*))                  (page-list (main *background*))))          (setf (page (main *background*)) (nth curpage (page-list (main *background*))))          (loop for page in (reverse saved-pages)                for i from 0 do                (loop for obj-list in page                       do                       (add-object-to-interface                           (nth i (page-list (main *background*)))                          (create-object (car obj-list) (cdr obj-list)))))          (reconstruct-menu-pages (length (page-list (main *background*))))          (toggle-page-check-mark curpage)          (set-window-title *interface-window* (pathname-name path))          (view-draw-contents (main *background*)))))))(defun file-save ()  (if (not brick-logo-path)    (file-save-as)    (progn      (with-cursor *watch*        (with-open-file (output-stream brick-logo-path :direction :output                                       :if-exists :supersede                                       :mac-file-creator :|BrLg|)          (print (position (page (main *background*))                            (page-list (main *background*)))                 output-stream)          (loop for page in (page-list (main *background*)) do                (loop for each-obj-list in (save-all-objects page)                      do (loop for each-trait in each-obj-list                               do                                (print each-trait output-stream))                      (terpri output-stream))                (terpri output-stream)                (write-line "@#$#@#$#@" output-stream)))))))(defun file-save-as ()  (let ((new-path (choose-new-file-dialog :prompt "Save Brick Logo Project as...")))    (unless (eq new-path 'cancelled)      (setq brick-logo-path new-path)      (set-window-title *interface-window* (pathname-name brick-logo-path))      (file-save))))(defun file-new ()  (with-cursor *watch*    (loop for p in (page-list (main *background*)) do          (delete-all-objects p))    (setf (page-list (main *background*)) (list (make-instance 'page                                                  :page-container (main *background*))))    (reconstruct-menu-pages 1)    (toggle-page-check-mark 0)    (set-window-title *interface-window* "Brick Logo")    (setf brick-logo-path nil)    (view-draw-contents (main *background*))));;; assumes the file has already been saved(defun file-quit ()  (ccl::confirmed-quit))(defclass logoblocks-application (application) ());;; I stole this from mcl's open doc handler(defmethod open-application-document ((a logoblocks-application) path &optional startup)  (declare (ignore startup))  (let ((type (mac-file-type path)))    (when (eq type :text)      (eval-enqueue `(file-ask-to-save-first 'load ,path)))));; this asks the user if he wants to save the file before doing;; function-to-do (which can be 'load or 'new or 'quit)(defun file-ask-to-save-first (function-to-do &optional path)  (block done    (if brick-logo-path      (let ((result              (catch-cancel                (y-or-n-dialog (concatenate 'string "Save changes to the project "                                            (pathname-name brick-logo-path) "?")))))        (cond ((equal result t) (file-save))              ((equal result :cancel) (return-from done nil))              (t nil)))      (let ((result              (catch-cancel                (y-or-n-dialog (concatenate 'string "Save changes to the project "                                            "Untitled?")))))        (cond ((equal result t) (file-save-as))              ((equal result :cancel) (return-from done nil))              (t nil))))    (if path      (do-branch function-to-do path)      (do-branch function-to-do))))(defun do-branch (function-to-do &optional path)  (cond ((eql function-to-do 'load)          (if path           (file-open path)           (file-open-dialog)))        ((eql function-to-do 'new) (file-new))        (t (file-quit))));------------------------------ Brick Logo Menu ---------------------------------------(defun make-brick-logo-menu ()   (make-instance 'menu    :menu-title "Brick Logo"    :menu-items (list                 (make-instance 'menu-item                   :menu-item-title "New"                   :menu-item-action #'(lambda () (file-ask-to-save-first 'new)))                 (make-instance 'menu-item                   :menu-item-title "Open..."                   :menu-item-action #'(lambda () (file-ask-to-save-first 'load)))                 (make-instance 'menu-item                   :menu-item-title "Save"                   :menu-item-action 'file-save)                 (make-instance 'menu-item                   :menu-item-title "Save as..."                   :menu-item-action 'file-save-as)                 (make-instance 'menu-item                   :menu-item-title "-")                 (make-instance 'menu-item                    :menu-item-title "View Code"                   :menu-item-action #'view-code)                 (make-instance 'menu-item                   :menu-item-title "Download Code"                   :menu-item-action #'(lambda ()                                          (run-graphic-code (make-code (main *background*))))                    :command-key #\D))))(defun make-page-menu ()  (make-instance 'menu    :menu-title "Page"    :menu-items (list                  (make-instance 'menu-item                   :menu-item-title "Add New Page"                    :menu-item-action #'(lambda () (add-new-page)))                 (make-instance 'menu-item                   :menu-item-title "Remove Current Page"                   :menu-item-action #'(lambda () (kill-current-page)))                 (make-instance 'menu-item                   :menu-item-title "-"))))(defun add-new-page ()  (let ((new-page (make-instance 'page :page-container (main *background*))))    (setf (page-list (main *background*))          (append (page-list (main *background*)) (list new-page)))    (add-menu-items (find-menu "Page")                    (make-instance 'menu-item                      :menu-item-title                       (format nil "Page ~D" (length (page-list (main *background*))))                      :menu-item-action                       (let ((j (1- (length (page-list (main *background*))))))                        #'(lambda () (toggle-page-check-mark j)                           (show-page j)))))    (erase (main *background*) (object-list (page (main *background*))))    (toggle-page-check-mark (1- (length (page-list (main *background*)))))    (setf (page (main *background*)) new-page)    (view-draw-contents (main *background*))))(defun kill-current-page ()  (let ((main (main *background*)))    (let ((curpage (page main)))      (delete-all-objects curpage)      (if (= 1 (length (page-list main)))        ;this is the last page        (progn           (setf curpage (make-instance 'page :page-container main))          (setf (page-list main) (list curpage))          (setf (page main) curpage))        (progn           (reconstruct-menu-pages (1- (length (page-list main))))          (let ((curpos (position curpage (page-list main))))          (let ((newpage                 (if (= curpos (1- (length (page-list main))))                   (- (length (page-list main)) 2)                   (position curpage (page-list main)))))            (setf (page-list main) (reverse (set-difference                                              (page-list main)                                              (list curpage))))            (setf (page main) (nth newpage (page-list main)))            (set-menu-item-check-mark (find-menu-item                                        (find-menu "Page")                                       (format nil "Page ~D" (1+ newpage)))                                      t)            (draw main (object-list (page main)))            (view-draw-contents main))))))))(defun reconstruct-menu-pages (number)  (when (find-menu "Page")    (menu-deinstall (find-menu "Page")))  (menu-install (make-page-menu))  (dotimes (i number)    (add-menu-items (find-menu "Page")                    (make-instance 'menu-item                      :menu-item-title (format nil "Page ~D" (+ i 1))                      :menu-item-action (let ((j i))                                          #'(lambda ()                                               (toggle-page-check-mark j)                                              (show-page j)))))))(defun show-page (number)  (let ((main (main *background*)))    (if (> number (1- (length (page-list main))))      (error (format nil "~D something is wrong" number)))    (unless (equal number (position (page main) (page-list main)))      (erase main (object-list (page main)))      (setf (page main) (nth number (page-list main)))      (draw main (object-list (page main)))      (view-draw-contents main))));; number is the one to turn on(defun toggle-page-check-mark (number)  (when (boundp '*background*)    (let ((off (position (page (main *background*))                         (page-list (main *background*)))))      (when off        (set-menu-item-check-mark (find-menu-item (find-menu "Page")                                                  (format nil "Page ~D" (+ off 1)))                                  nil))      (set-menu-item-check-mark (find-menu-item (find-menu "Page")                                                (format nil "Page ~D" (+ number 1)))                                t))))
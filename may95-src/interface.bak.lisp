;;;; Interface for Visual Programming Language. (VPL);;;; Albert Castillo 5/7/95;;;; Andrew Begel  4/6/95;;;;;;;; Evaluate this buffer, then choose the Menu/New Window option;;;; Select your objects from the Palette to build a program.;;;; Choose Edit/Clear Screen to start over.;;;; After building your program, choose the Eval/Run option;;;; (make sure the brick is plugged in! :-);;;; NOTE: Parsing of the screen objects (for now) is done in the;;;; order they were placed on the screen...be careful how you place the;;;; objects. THis will be fixed soon ...;;;;;;;;;;;;;;;;;;;; GLOBALS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defvar *main*)(defvar *palette*);;;;;;;;;;;;;;;;;;;; REQUIRES ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(require :quickdraw)(load "home:toolbox.lisp")(load "home:objects.lisp")(load "home:menu.lisp")(load "home:bdstartup.lisp");;;;;;;;;;;;;;;;;;;; CLASS DEFINITIONS ;;;;;;;;;;;;;;;;;;;;;;;;;;;; abstract base class for all windows in the VPL(defclass vpl-mixin ()  ((buffer1 :accessor buffer1 :initarg :buffer1)   (object-list :accessor object-list :initarg :objects :initform nil)))(defclass vpl-window (vpl-mixin window)  ((buffer2 :accessor buffer2 :initarg :buffer2)   (grid-space-x :accessor grid-space-x :initarg :grid-space-x :initform 50)   (grid-space-y :accessor grid-space-y :initarg :grid-space-y :initform 25)   (bitmap :accessor bitmap :initarg :bitmap :initform nil)   (object-table :accessor object-table :initarg :object-table :initform nil)))(defclass vpl-windoid (vpl-mixin windoid)  ((active-item :accessor active-item :initarg :active-item :initform nil)));;;;;;;;;;;;;;;;;;;; STARTUP ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defun make-interface ()  (when (boundp '*main*)    (when (wptr *main*)      (window-close *main*)))  (setf *main* (make-instance 'vpl-window                 :window-type :document                 :color-p t                 :view-size #@(600 300)                 :view-position #@(10 40)                 :window-title "BrickLogo"                 :window-show nil))  (setf *palette* (make-instance 'vpl-windoid                    :color-p t                    :view-size #@(100 284)                    :view-position #@(13 53)                    :window-title "Palette"                    :close-box-p nil                    :window-show nil))  (setup-offscreens *main*)  (setup-offscreens *palette*)  (setup-palette *palette*)  (setup-code-gen *main*)  (set-back-color *main* *light-gray-color*)  (set-back-color *palette* *light-gray-color*)  (window-show *main*)  (window-show *palette*))(defmethod setup-offscreens ((view vpl-mixin))  (setf (buffer1 view) (make-offscreen-gworld view))  (offscreen (buffer1 view)             (#_eraserect (pref (buffer1 view) :cgrafport.portrect)))); The main window has an extra buffer to setup(defmethod setup-offscreens :after ((view vpl-window))  (setf (buffer2 view) (make-offscreen-gworld view))  (offscreen (buffer2 view)             (#_eraserect (pref (buffer2 view) :cgrafport.portrect))));;; SETUP CODE GENERATION STRUCTURES ;;;(defmethod setup-code-gen ((view vpl-window))  (setf (bitmap view)         (make-array '(12 12) :initial-element 0 :element-type 'bit))  (setf (object-table view) (make-hash-table :size 150)));;; SETUP PALETTE ;;;(defvar *violet-color* (make-color 35000 25000 65000))(defvar *skyblue-color* (make-color 25000 25000 65000)); Modifies *palette*: creates and installs primitives into the palette(defmethod setup-palette ((view vpl-windoid))  ; TRIGGER OBJECTS  (add-interface-object *palette* (make-trigger                                    'switch *yellow-color*                                    '<switcha> #@(25 10)))  (add-interface-object *palette* (make-trigger                                    'sensor *skyblue-color*                                    '<sensora> #@(25 50)))  ; DIVIDING LINE  (offscreen (buffer1 *palette*) (#_moveto 0 82) (#_line 100 0))  ; ACTION OBJECTS  (add-interface-object *palette* (make-action-box                                    'a *light-blue-color* '<a> #@(25 90)))  (add-interface-object *palette* (make-action-box                                    'on *green-color* '<on> #@(25 130)))  (add-interface-object *palette* (make-action-box                                    'off *red-color* '<off> #@(25 170)))  (add-interface-object *palette* (make-action-box                                    'rd *orange-color* '<rd> #@(25 210)))  (add-interface-object *palette* (make-action-box                                    'wait *violet-color*                                    (list '<%num> 0 10 '<wait>) #@(25 250))))  ;;;;;;;;;;;;;;;;;;;;;; GENERAL WINDOW METHODS ;;;;;;;;;;;;;;;;;;;;;;;;(defmethod window-close ((window vpl-window))  (delete-all-objects window)  (kill-interface)  (call-next-method))(defmethod kill-interface ()  (without-interrupts   (kill-offscreens *main*)   (kill-offscreens *palette*)   (kill-code-gen *main*)   (window-close *palette*)))(defmethod kill-offscreens ((view vpl-mixin))  (when (buffer1 view)    (#_DisposeGWorld (buffer1 view)))  (setf (buffer1 view) nil)); the main window has an extra buffer to dispose of(defmethod kill-offscreens :after ((view vpl-window))  (when (buffer2 view)    (#_DisposeGWorld (buffer2 view)))  (setf (buffer2 view) nil))(defmethod kill-code-gen ((view vpl-window))  (clrhash (object-table view))  (setf (object-table view) nil)  (setf (bitmap view) nil))(defmethod clear ((theview vpl-mixin))  (offscreen (buffer1 theview)             (#_eraserect (pref (buffer1 theview) :cgrafport.portrect)))  (view-draw-contents theview))(defmethod view-draw-contents ((view vpl-mixin))  (copy-from-offscreen view (buffer1 view)        (rref (wptr view) :grafport.portrect))); Make sure active palette item is highlighted on redraw(defmethod view-draw-contents :after ((view vpl-windoid))  (let ((oldactive (active-item *palette*)))    (if oldactive (invert-region view (hilitergn oldactive))))); Hide the palette when the Main window is deactivated(defmethod view-deactivate-event-handler ((view vpl-window))  (window-hide *palette*)  (call-next-method));()); Show the palette when the Main window is active(defmethod view-activate-event-handler ((view vpl-window))  (window-show *palette*)  (call-next-method));;;;;;;;;;;;;;;;;;; ADDING/DELETING INTERFACE OBJECTS ;;;;;;;;;;;;;;;;(defmethod add-interface-object ((view vpl-mixin) (newobject object))  (snap-objects-to-grid view (list newobject))  ; add new obj to the object-list  (push newobject (object-list view))  (draw-object newobject (buffer1 view))  (view-draw-contents view)); After adding a main-window-object, update the code-generation structures(defmethod add-interface-object :after ((view vpl-window) (newobject object))  (let ((x-coord (/ (left (boundrect newobject)) 50))        (y-coord (/ (top (boundrect newobject)) 25)))    ; add new obj to the hash table, using location as key    (setf (gethash            (+ (* 12 x-coord) y-coord) ; key           (object-table view))           newobject)    ; set bitmap to reflect new object    (setf (bit (bitmap view)                x-coord               y-coord)          1))); After adding a palette-object, setup its highlight region(defmethod add-interface-object :after ((view vpl-windoid) (newobject object))  (let ((thergn (new-region)))    (rlet ((therect :rect :topleft #@(0 0) :botright #@(60 35)))      (move-rect therect                  (subtract-points (topleft (boundrect newobject)) #@(5 5)))      (#_OpenRgn)      (with-fore-color *black-color*        (#_framerect therect))      (#_CloseRgn thergn)      (difference-region thergn (boundrgn newobject) thergn)      (setf (hilitergn newobject) (copy-region thergn))      (dispose-region thergn))))(defmethod delete-objects ((view vpl-mixin) list-of-objs)  (loop for obj in list-of-objs do        (setf (object-list view) (reverse (set-difference                                            (object-list view)                                            (list obj))))        (eraseobj view (list obj))        (delete-object obj)) ;specialized on each type of object  (view-draw-contents view))(defmethod delete-all-objects ((view vpl-mixin))  (delete-objects view (object-list view))); Reset the code-generation structures when all objects are deleted(defmethod delete-all-objects :after ((view vpl-window))  (clrhash (object-table view))  (setf (bitmap view)         (make-array '(12 12) :initial-element 0 :element-type 'bit)))  ;----------- ORDERING OBJECTS within the INTERFACE ----------------(defmethod bring-to-front ((view vpl-mixin) (obj object))  (unless (equal (first (object-list view)) obj)    (setf (object-list view) (append (list obj)                                      (reverse (set-difference                                                (object-list view)                                               (list obj)))))))(defmethod push-to-back ((view vpl-mixin) (obj object))  (unless (equal (last (object-list view)) obj)    (setf (object-list view) (append (reverse (set-difference                                                (object-list view)                                                (list obj)))                                      (list obj)))))(defmethod bring-many-to-front ((view vpl-mixin) list-of-objects)  (setf (object-list view) (append list-of-objects                                    (reverse                                     (set-difference (object-list view)                                                    list-of-objects)))))(defmethod push-many-to-back ((view vpl-mixin) list-of-objects)  (setf (object-list view) (append (reverse (set-difference                                              (object-list view)                                              list-of-objects))                                   list-of-objects)));------------------- CLICKING in the INTERFACE ---------------------(defmethod view-click-event-handler ((view vpl-window) where)  (if (double-click-p)    ; OPTION 1: Double-click object    (let ((obj (find-clicked-object view where)))      (when obj         (toggle obj)        (draw-object obj (buffer1 view))        (view-draw-contents view)))    (let ((theactive (active-item *palette*)))      (if theactive        ; OPTION 2: Add a new object of type of active palette item (if any)        (case (class-name (class-of theactive))          ((action onoff wait motor direction)           (add-interface-object view (make-action-box                                        (name theactive)                                        (color-list theactive)                                        (definition theactive)                                        (subtract-points where #@(25 12))))           ; un-highlight the palette item           (invert-region *palette* (hilitergn (active-item *palette*)))           ; and now that we're done, show no active palette item           (setf (active-item *palette*) nil))          ((trigger switch)           (add-interface-object view (make-trigger                                        (name theactive)                                        (color-list theactive)                                        (definition theactive)                                        (subtract-points where #@(25 12))))           (invert-region *palette* (hilitergn (active-item *palette*)))           (setf (active-item *palette*) nil)))                ; OPTION 3: Move an existing object        (let ((obj (find-clicked-object view where)))          (if obj             (move-objects view (list obj) where)))))))      (defmethod view-click-event-handler ((view vpl-windoid) where)  (let ((obj (find-clicked-object view where))        (oldactive (active-item *palette*)))    (if oldactive       ; un-highlight old active item      (invert-region view (hilitergn oldactive)))    (when obj       ;(#_sysbeep 10)      ; hightlight new active item      (invert-region view (hilitergn obj)))    ; set active-item to object selected or to nil if none selected    (setf (active-item *palette*) obj)))(defmethod find-clicked-object ((view vpl-mixin) where)  (loop for obj in (object-list view)        when (point-in-rect-p (boundrect obj) where)        do (when (point-in-region-p (boundrgn obj) where)             (return obj))));------------------- MOVING OBJECTS in INTERFACE --------------------;; move objects within the main view(defmethod move-objects ((view vpl-window) list-of-objs where)  (bring-many-to-front view list-of-objs)  (remove-objs-from-main view list-of-objs)  (move-draw-objects view list-of-objs where)  (snap-objects-to-grid view list-of-objs)  (draw view list-of-objs)  (view-draw-contents view))(defmethod remove-objs-from-main ((view vpl-window) list-of-objs)  (eraseobj view list-of-objs)  (loop for obj in (set-difference (object-list view) list-of-objs)        do (draw-object obj (buffer1 view))))(defmethod move-draw-objects ((view vpl-window) list-of-objs where)  (let ((old-mouse where)        (new-mouse (view-mouse-position view)))    (let ((final-point new-mouse))      (without-interrupts       (loop while (mouse-down-p) do             (setf new-mouse                    (limit-point-to-view view (view-mouse-position view)))             (unless (equal new-mouse old-mouse)               (let ((diff-mouse (subtract-points new-mouse old-mouse)))                 (displace-objects view list-of-objs diff-mouse))               (setf old-mouse new-mouse)               (move-function view list-of-objs))             finally (setf final-point new-mouse)))      final-point)))(defmethod limit-point-to-view ((view vpl-window) mouse-point)  (let ((topleft #@(0 0))        (botright (add-points #@(0 0)                               (view-size view))))    (if (> (point-h mouse-point) (point-h botright))      (setf mouse-point (make-point (point-h botright)                                    (point-v mouse-point)))      (when (< (point-h mouse-point) (point-h topleft))        (setf mouse-point (make-point (point-h topleft)                                      (point-v mouse-point)))))    (if (> (point-v mouse-point) (point-v botright))      (setf mouse-point (make-point (point-h mouse-point)                                    (point-v botright)))      (when (< (point-v mouse-point) (point-v topleft))        (setf mouse-point (make-point (point-h mouse-point)                                      (point-v topleft)))))    mouse-point))(defmethod displace-objects ((view vpl-window) list-of-objs diff-mouse)  (copy-offscreen-to-offscreen (buffer1 view) (buffer2 view)                               (pref (wptr view) :cgrafport.portrect))    (loop for obj in list-of-objs do             (offset-rect (boundrect obj) diff-mouse)             (offset-region (boundrgn obj) diff-mouse)             (draw-object obj (buffer2 view)))  (copy-from-offscreen view (buffer2 view)                       (pref (wptr view) :cgrafport.portrect)));;bug; view is getting background instead of main or palette. Yucky.;;pallette-to-main is problem. (defmethod move-function ((view vpl-window) list-of-objs)  (declare (ignore list-of-objs)))#|(rlet ((destrect :rect :topleft #@(0 0) :botright #@(0 0)))    (let ((otherobjs (reverse (set-difference (object-list view) list-of-objs)))          (destrgn (new-region))          (destrgn1 (new-region)))      (loop for obj in list-of-objs do            (loop for otherobj in otherobjs do                  (intersect-rect (boundrect obj) (boundrect otherobj) destrect)                  (unless (Empty-rect-p destrect)                    (intersect-region (boundrgn obj) (Boundrgn otherobj) destrgn)                    ;(difference-region (boundrgn otherobj) (boundrgn obj) destrgn1)                    (unless (empty-region-p destrgn)                      ;(empty-region-p destrgn1))                      (touch-function view obj otherobj))))      (dispose-region destrgn)      (dispose-region destrgn1)))))(defmethod touch-function ((view vpl-mixin) obj1 obj2)  ;;obj1 is moving and has touched the edge of obj2  (print "beep"))|#(defmethod snap-objects-to-grid ((view vpl-windoid) list-of-objs)  (declare (ignore list-of-objs)))(defmethod snap-objects-to-grid ((view vpl-window) list-of-objs)  (let ((grid-x (grid-space-x view))        (grid-y (Grid-space-y view)))    (loop for obj in list-of-objs do          (let ((left-offset (mod (left (boundrect obj)) grid-x))                (top-offset (mod (top (boundrect obj)) grid-y)))            (let ((x-offset (if (>= left-offset (/ grid-x 2))                             (- grid-x left-offset)                             (- left-offset)))                  (y-offset (if (>= top-offset (/ grid-y 2))                            (- grid-y top-offset)                            (- top-offset))))              (move-object obj (make-point (+ (left (boundrect obj))                                              x-offset)                                           (+ (top (boundrect obj))                                              y-offset))))))));;;;;;;;;;;;;;;;;;;;;;; DRAWING ON A WINDOW ;;;;;;;;;;;;;;;;;;;;;;;;;(defmethod draw ((view vpl-mixin) list-of-objs)  (loop for obj in list-of-objs do        (draw-object obj (buffer1 view)))); Renamed erase to eraseobj due to conflict with Brick code(defmethod eraseobj ((view vpl-mixin) list-of-objs)  (loop for obj in list-of-objs do        (erase-object obj (buffer1 view))));;;;;;;;;;;;;;;;;;;;;;;; CODE GENERATION ;;;;;;;;;;;;;;;;;;;;;;;;;;;;(defvar *tempstack*)(defmethod generate-code ((view vpl-window))  (let ((thecode (generate-code-segment (fetch-objects-to-encode view))))    (when thecode      (loop while *tempstack* do            (push (pop *tempstack*) thecode))      (setf thecode (append thecode '(run) ))      (eval (reverse thecode))      )))(defmethod generate-code1 ((view vpl-window))  (let ((allthecode (fetch-objects-to-encode1 view)))    (when allthecode      (loop for codeblock in allthecode do            (let ((thecode (generate-code-segment codeblock)))              (loop while *tempstack* do                    (push (pop *tempstack*) thecode))              (setf thecode (append thecode '(run) ))              (eval (reverse thecode))              )))))(defmethod debug-code ((view vpl-window))  (let ((thecode (generate-code-segment (fetch-objects-to-encode view))))    (when thecode      (loop while *tempstack* do            (push (pop *tempstack*) thecode))      (setf thecode (append thecode '(run) ))      (reverse thecode)      )))(defmethod debug-code1 ((view vpl-window))  (let ((allthecode (fetch-objects-to-encode1 view))        (debugcode nil))    (when allthecode      (loop for codeblock in allthecode do            (let ((thecode (generate-code-segment codeblock)))              (loop while *tempstack* do                    (push (pop *tempstack*) thecode))              (setf thecode (append thecode '(run) ))              (push (reverse thecode) debugcode)              )))    (reverse debugcode)))(defmethod fetch-objects-to-encode ((view vpl-window))  (reverse (object-list view)));(gethash (+ (* 12 i) j) (object-table view))(defmethod fetch-objects-to-encode1 ((view vpl-window))  (let ((thecode nil) (codesegment nil) (codeblock? nil)        (thebitmap (bitmap view)))    (dotimes (i (array-dimension thebitmap 0))      (dotimes (j (array-dimension thebitmap 1))                (let ((thebit (bit thebitmap i j)))          (cond           ((and (eql thebit 0) (not codeblock?)) nil)                      ((and (eql thebit 0) codeblock?)            (setf codeblock? nil)             (push (reverse codesegment) thecode)            (setf codesegment nil))                      ((and thebit (not codeblock?))             (setf codeblock? t)            (push              ;(+ (* 12 i) j)              (gethash (+ (* 12 i) j) (object-table view))             codesegment))                      ((and thebit codeblock?)            (push              ;(+ (* 12 i) j)              (gethash (+ (* 12 i) j) (object-table view))             codesegment))))))        (reverse thecode)));                  (if (eql (bit thebitmap i j) 1);                    (push ;                     (+ (* 12 i) j);                     thecode))));            (reverse thecode)))(defun generate-code-segment (object-list)  (setf *tempstack* nil)  (let ((thecode (list)) (count? nil) (counter 1))    (if object-list       (loop for obj in object-list do              (let ((codeout (parse-obj obj)))              (cond                ((listp codeout)                ; if complex parse, push each element                (loop for code-pieces in codeout do                      (if count? (setf counter (1+ counter)))                      (push code-pieces thecode)))                                              (t                 ; otherwise, just push it directly                (if count? (setf counter (1+ counter)))                (push codeout thecode))))                        (if (eql (class-name (class-of obj)) 'switch) (setf count? t))))    (when count?      ; set the list arguments for the Action objects...<%list> x y ...      ; This is not very efficient, but it works for now... :-(      ;(push (floor (/ counter 256)) *tempstack*)      ;(push (mod counter 256) *tempstack*))      (setf thecode (substitute (floor (/ counter 256)) 'foo thecode))      (setf thecode (substitute (mod counter 256) 'bar thecode)))        thecode))(defmethod parse-obj ((obj action))  (definition obj))(defmethod parse-obj ((obj switch))   (push '<when> *tempstack*)  (push '<%eol> *tempstack*)  (list '<%list> 0 2 (definition obj) '<%eolr> '<%list> 'foo 'bar))(defmethod parse-obj ((obj trigger))  ())#|WHEN SWITCHA [on] becomes (note use of %eolr) (run <%list> 0 2 <switcha> <%eolr> <%list> 0 2 <on> <%eol> <when>)|#;;;;;;;;;;;;;;;;;;;;;;; BRING UP THE MENU AND GO! ;;;;;;;;;;;;;;;;;(menu)
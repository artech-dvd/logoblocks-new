;;;; Random ToolBOX shit. (12/9/94);;;; RANDOM FUNCS(defmacro top (rect)  `(pref ,rect :rect.top))(defmacro right (rect)  `(pref ,rect :rect.right))(defmacro left (rect)  `(pref ,rect :rect.left))(defmacro bottom (rect)  `(pref ,rect :rect.bottom))(defmacro topleft (rect)  `(pref ,rect :rect.topleft))(defmacro botright (rect)  `(pref ,rect :rect.botright))(defun topright (rect)  (make-point (right rect) (top rect)))(defun botleft (rect)  (make-point (left rect) (bottom rect)))(defun rect-width (rect)  (- (right rect) (left rect)))(defun rect-height (rect)  (- (bottom rect) (top rect)))(defun rect-size (rect)  (subtract-points (botright rect) (topleft rect)))(defun rect-equal (rect1 rect2)  (and (equal (topleft rect1) (topleft rect2))       (equal (botright rect1) (botright rect2))))(defun copy-rect (rect)  (make-record :rect :topleft (topleft rect) :botright (botright rect)))(defun ncopy-rect (rect rect-dest)  (setf (topleft rect-dest) (topleft rect))  (Setf (botright rect-dest) (botright rect)));returns the destructively modified rectangle(defun move-rect (rect h &optional v)  (when v (setf h (make-point h v)))  (let ((size (rect-size rect)))    (setf (topleft rect) h)    (setf (botright rect) (add-points h size)))  rect)(defun bound-region-rect (region)  (with-dereferenced-handles ((reg region))    (let ((size-rect (rref reg :region.rgnbbox :storage :pointer)))      (copy-rect size-rect))));; returns 'click or 'drag if the mouse action is a click or a drag(defmethod click-or-drag? ((view view) where)  (let ((cont-loop? t)        (click-or-drag 'click)        (current-time (#_tickcount))) ;tickcount has 60 clicks per second    (loop while (and cont-loop? (mouse-down-p)) do            (if (or (not (close? (view-mouse-position view) where))                    (> (- (#_tickcount) current-time) 30))                                  (progn                       (setf cont-loop? nil)                      (setf click-or-drag 'drag))))    click-or-drag))(defun close? (point1 point2)  (and (< (abs (- (point-h point1) (point-h point2))) 5)       (< (abs (- (point-v point1) (point-v point2))) 5)));;;; OFFSCREEN GWORLD OPs;;; returns an offscreen-gworld(defmethod make-offscreen-gworld ((view simple-view) &optional rect)  (when (not rect) (setf rect (pref (Wptr view) :grafport.portrect)))  (with-focused-view view    (%stack-block ((result 4))      (#_NewGWorld result 0 rect (%null-ptr) (%null-ptr) 0)      (%get-ptr result))));;; form for doing an operation on the offscreen gworld(defmacro offscreen (offscreen-world &rest forms)  `(%stack-block ((ogd 4)(oport 4))     (#_lockpixels (#_getGworldPixmap ,offscreen-world))      (#_getgworld ogd oport)     (#_setgworld ,offscreen-world (%null-ptr))     (unwind-protect (progn ,@forms)       (#_setgworld (%get-ptr ogd)(%get-ptr oport))       (#_unlockpixels (#_getGworldPixmap ,offscreen-world)))))(defmethod copy-from-offscreen ((view simple-view) offscreen-gworld rect1                                &key (rect2 rect1) (rgn (%null-ptr)))  (with-focused-view view    (#_lockpixels (#_getgworldpixmap offscreen-gworld))    (#_copybits (%inc-ptr offscreen-gworld 2) (%inc-ptr (wptr view) 2)     rect1 rect2 0 rgn)    (#_unlockpixels (#_getgworldpixmap offscreen-gworld))))(defmethod copy-to-offscreen ((View simple-view) offscreen-gworld rect1                              &key (rect2 rect1) (rgn (%null-ptr)))  (%stack-block ((ogd 4)(oport 4))    (#_lockpixels (#_getGworldPixmap offscreen-gworld))     (#_getgworld ogd oport)    (#_setgworld offscreen-gworld (%null-ptr))    (#_copybits (%inc-ptr (wptr view) 2) (%inc-ptr offscreen-gworld 2)     rect1 rect2 0 rgn)    (#_setgworld (%get-ptr ogd)(%get-ptr oport))    (#_unlockpixels (#_getGworldPixmap offscreen-gworld))))(defmethod copy-offscreen-to-offscreen            (offscreen1 offscreen2 rect1 &key (rect2 rect1) (rgn (%null-ptr)))  (%stack-block ((ogd 4)(oport 4))    (#_lockpixels (#_getGworldPixmap offscreen1))    (#_lockpixels (#_getGworldPixmap offscreen2))     (#_getgworld ogd oport)    (#_setgworld offscreen1 (%null-ptr))    (#_copybits (%inc-ptr offscreen1 2) (%inc-ptr offscreen2 2)     rect1 rect2 0 rgn)    (#_setgworld (%get-ptr ogd)(%get-ptr oport))    (#_unlockpixels (#_getGworldPixmap offscreen2))    (#_unlockpixels (#_getGworldPixmap offscreen1))))(defvar *current-cursor-all* *Arrow-cursor*)(defvar *current-cursor-interface* *arrow-cursor*);;; NOTE: Cursors will only be active when the resource of the cursors is open. ;;; This will be true in the standalone version, or if the resources file is open.(defvar *pointing-hand* 256)(defvar *hand* 257)(defvar *pulling-hand* 258)(defvar *fist* 259)(defvar *abort-cursor* 512)(defvar *ne-sw-resize* 132)(defvar *nw-se-resize* 131)(defvar *n-s-resize* 130)(defvar *e-w-resize* 129)(defvar *watch* 4)(defvar *arrow* 0);(defmethod view-cursor ((view starlogo-view) point);  (declare (ignore point));  *current-cursor-all*);(defun change-cursor-all (cursor-number);  (setf *current-cursor-all* cursor-number);  (update-cursor));(defun change-cursor (cursor-number);  (setf *current-cursor-interface* cursor-number);  (update-cursor))(defmacro with-clipped-region-in-view (view region &rest forms)  `(with-focused-view ,view     (let ((temp-region (clip-region ,view))           (temp-region1 (copy-region ,region)))       (intersect-region temp-region temp-region1 temp-region1)       (set-clip-region ,view temp-region1)       (progn ,@forms)       (set-clip-region ,view temp-region)       (dispose-region temp-region)       (dispose-region temp-region1))))